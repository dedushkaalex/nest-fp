# Шпаргалка по NestJS

Этот файл содержит краткий конспект по ключевым темам, которые мы разобрали.

## 1. Модули: Обмен Провайдерами

Чтобы использовать сервис из одного модуля (`CatsModule`) в другом (`ZooModule`), необходимо следовать правилу инкапсуляции.

### ✅ Правильный способ: `imports` и `exports`

Это гарантирует, что в приложении будет только **один экземпляр** сервиса (Singleton).

1.  **Экспортируйте** сервис из его "родного" модуля.

    ```typescript
    // src/cats/cats.module.ts
    @Module({
      providers: [CatsService],
      exports: [CatsService], // <-- Делаем сервис доступным для других модулей
    })
    export class CatsModule {}
    ```

2.  **Импортируйте** весь модуль в тот модуль, где он нужен.

    ```typescript
    // src/zoo/zoo.module.ts
    @Module({
      imports: [CatsModule], // <-- Импортируем модуль целиком
      providers: [ZooService],
    })
    export class ZooModule {}
    ```

### ❌ Неправильный способ: Прямое добавление в `providers`

```typescript
// НЕ ДЕЛАЙТЕ ТАК!
@Module({
  // providers: [ZooService, CatsService]
})
export class ZooModule {}
```

-   **Почему это плохо:**
    -   **Нарушение Singleton:** Создается новый, локальный экземпляр `CatsService` только для `ZooModule`. Другие модули получат другие экземпляры, что ведет к рассинхронизации.
    -   **Нарушение инкапсуляции:** `ZooModule` начинает отвечать за создание зависимости из другого модуля.

---

## 2. Глобальные модули (`@Global`)

Декоратор `@Global()` делает экспортируемые провайдеры модуля доступными во всем приложении без необходимости импортировать этот модуль везде.

```typescript
// src/config/config.module.ts
import { Module, Global } from '@nestjs/common';

@Global() // <-- Помечаем модуль как глобальный
@Module({
  providers: [ConfigService],
  exports: [ConfigService],
})
export class ConfigModule {}
```

-   **Использование:** Глобальный модуль нужно импортировать **один раз** в корневом `AppModule`.
-   **Готовый пример (`@nestjs/config`):**
    ```typescript
    // app.module.ts
    ConfigModule.forRoot({
      isGlobal: true, // <-- Этот флаг делает то же самое
    }),
    ```
-   **Когда использовать:** Только для действительно универсальных вещей (конфигурация, подключение к БД, логгеры).
-   **⚠️ Предостережение:** Злоупотребление `@Global()` скрывает зависимости и усложняет архитектуру.

---

## 3. Пайпы (Pipes)

Пайп — это класс, который выполняет **трансформацию** и/или **валидацию** входящих данных запроса перед тем, как они попадут в метод контроллера.

-   **Жизненный цикл:** `Middleware` -> `Guards` -> `Interceptors (до)` -> **✨ PIPES ✨** -> `Метод контроллера`.
-   Если пайп выбрасывает исключение (например, при ошибке валидации), **метод контроллера не вызывается**. NestJS автоматически отправляет клиенту ответ `400 Bad Request`.
-   **Встроенные пайпы:** `ValidationPipe`, `ParseIntPipe`, `ParseBoolPipe`, `DefaultValuePipe` и др.

---

## 4. Кастомные Провайдеры

Это гибкие способы регистрации зависимостей.

### `useValue`

-   **Идея:** Внедрить **уже существующее значение** (объект, константу).
-   **Когда:**
    1.  Интеграция с внешними библиотеками, которые создают объекты вне NestJS.
    2.  Внедрение статических объектов конфигурации.
    3.  **Мокинг (Mocking)** зависимостей в тестах.
-   **Пример:**
    ```typescript
    const mockService = { findAll: () => ['Test'] };

    {
      provide: CatsService,
      useValue: mockService,
    }
    ```

### `useFactory`

-   **Идея:** Динамическое создание зависимости с помощью **функции-фабрики**. Самый мощный способ.
-   **Когда:**
    1.  Логика создания зависит от других сервисов (`inject`).
    2.  Нужно создать разный сервис в зависимости от окружения (prod/dev).
    3.  Создание зависимости требует **асинхронной** операции (`async/await`).
-   **Пример:**
    ```typescript
    {
      provide: 'DATABASE_CONNECTION',
      useFactory: async (config: ConfigService) => {
        const connection = new DbClient();
        await connection.connect(config.get('DB_URL'));
        return connection;
      },
      inject: [ConfigService], // <-- Зависимости для фабрики
    }
    ```

### `useExisting`

-   **Идея:** Создать **псевдоним (алиас)** для уже существующего сервиса.
-   **Когда:**
    1.  Нужно дать сервису второе, более абстрактное имя, чтобы уменьшить связность кода.
    2.  Обеспечить несколько "точек входа" к одному и тому же экземпляру сервиса.
-   **Пример:**
    ```typescript
    {
      provide: 'USERS_CACHE', // <-- Новый псевдоним
      useExisting: CacheService, // <-- Указывает на существующий сервис
    }
    ```

### Сводка по провайдерам

| Тип          | Ключевая идея                                        | Что делает?      |
|--------------|------------------------------------------------------|------------------|
| **`useClass`**   | "Вот класс, создай его экземпляр" (поведение по умолчанию) | **Создает**      |
| **`useValue`**   | "Вот уже готовое значение, просто используй его"     | **Ничего не создает** |
| **`useFactory`** | "Вот функция, выполни ее, чтобы создать значение"   | **Создает**      |
| **`useExisting`**| "Вот псевдоним, который ссылается на другой сервис" | **Ничего не создает** |

